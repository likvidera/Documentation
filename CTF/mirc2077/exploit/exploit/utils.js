/* UTILITIES */
function ArrayFrom(val) {
	r = Array();
	for(i = 0; i < val.length; i++) {
		r.push(val[i]);
	}
}
function ArrayFromRev(val) {
	r = Array();
	for(i = 0; i < val.length; i++) {
		r.push(val[i]);
	}
	return r.reverse();
}

function hexu(val) {
	return "0x" + val.toString(16);
}

function print_val(ptr, i) {
	console.log("val 0x" + ptr[i].toString(16));
}

function log(data) {
	console.log(data);
}

function success(data) {
	console.log("[+]" + data);
}

function fail(data) {
	console.log("[-]" + data);
}

function print_obj(iobj, joff) {
	console.log("===============================");
	console.log("obj ( 0) " + d2i(spray[iobj][joff]).toString());
	console.log("obj ( 1) " + d2i(spray[iobj][joff+1]).toString());
	console.log("obj ( 2) " + d2i(spray[iobj][joff+2]).toString());
	console.log("obj ( 3) " + d2i(spray[iobj][joff+3]).toString());
	console.log("obj ( 4) " + d2i(spray[iobj][joff+4]).toString());
	console.log("obj ( 5) " + d2i(spray[iobj][joff+5]).toString());
	console.log("obj ( 6) " + d2i(spray[iobj][joff+6]).toString());
	console.log("obj ( 7) " + d2i(spray[iobj][joff+7]).toString());
	console.log("obj ( 8) " + d2i(spray[iobj][joff+8]).toString());
	console.log("obj ( 9) " + d2i(spray[iobj][joff+9]).toString());
	console.log("obj (10) " + d2i(spray[iobj][joff+10]).toString());
	console.log("obj (11) " + d2i(spray[iobj][joff+11]).toString());
	console.log("obj (12) " + d2i(spray[iobj][joff+12]).toString());
	console.log("===============================");
}

// Return the hexadecimal representation of the given byte.
function hex(b) {
	return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
	var res = [];
	for (var i = 0; i < bytes.length; i++)
			res.push(hex(bytes[i]));

	return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
	if (hexstr.length % 2 == 1)
			throw new TypeError("Invalid hex string");

	var bytes = new Uint8Array(hexstr.length / 2);
	for (var i = 0; i < hexstr.length; i += 2)
			bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);
	return bytes;
}

var Struct = (function() {
	// Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
	var buffer      = new ArrayBuffer(8);
	var byteView    = new Uint8Array(buffer);
	var uint32View  = new Uint32Array(buffer);
	var float64View = new Float64Array(buffer);

	return {
			pack: function(type, value) {
					var view = type;        // See below
					view[0] = value;
					return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
			},

			unpack: function(type, bytes) {
					if (bytes.length !== type.BYTES_PER_ELEMENT)
							throw Error("Invalid bytearray");

					var view = type;        // See below
					byteView.set(bytes);
					return view[0];
			},

			// Available types.
			int8:    byteView,
			int32:   uint32View,
			float64: float64View
	};
})();